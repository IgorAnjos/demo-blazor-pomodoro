@page "/"
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="pomodoro-container">
    <div class="pomodoro-card">
        
        <div class="timer-types">
            <button class="timer-type-btn @(_timerType == TimerType.Pomodoro ? "active" : "")" 
                    @onclick="SetToPomodoro">
                üçÖ Pomodoro
            </button>
            <button class="timer-type-btn @(_timerType == TimerType.ShortBreak ? "active" : "")" 
                    @onclick="SetToShortBreak">
                ‚òï Short Break
            </button>
            <button class="timer-type-btn @(_timerType == TimerType.LongBreak ? "active" : "")" 
                    @onclick="SetToLongBreak">
                üå¥ Long Break
            </button>
        </div>

        <div class="timer-display @GetTimerClass()">
            <div class="timer-text">
                @_timeLeft.ToString("mm\\:ss")
            </div>
        </div>

        @if (_pomodoroSettings == null)
        {
            <p class="custom-message">
                ‚öôÔ∏è First, configure your timer durations in Settings
            </p>
        }
        else
        {
            <div class="timer-controls">
                <button class="btn-control btn-start" @onclick="SetTimer">
                    @(_timerHasStarted ? "‚è∏ Pause" : "‚ñ∂ Start")
                </button>
                <button class="btn-control btn-reset" @onclick="ResetTimer">
                    üîÑ Reset
                </button>
            </div>
        }

        @if (_pomodoroCompleted > 0)
        {
            <div class="stats-container">
                <span class="stats-badge">
                    üéØ @_pomodoroCompleted pomodoros completed today!
                </span>
            </div>
        }
    </div>
</div>

@code {
    private PomodoroSettings? _pomodoroSettings;
    private bool _timerHasStarted;
    private PeriodicTimer? _periodicTimer;
    private TimeSpan _timeLeft = TimeSpan.Zero;
    private TimerType _timerType = TimerType.Pomodoro;
    private int _pomodoroCompleted = 0;
    private CancellationTokenSource? _cancellationTokenSource;
    private bool _isRendered = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _isRendered = true;
            await LoadSettings();
            await LoadPomodoroCount();
            ResetTimerToCurrentType();
            StateHasChanged();
        }
    }

    private async Task LoadSettings()
    {
        var json = await localStorage.GetItemAsync<string>("pomodoroSettings");
        if (!string.IsNullOrEmpty(json))
        {
            _pomodoroSettings = System.Text.Json.JsonSerializer.Deserialize<PomodoroSettings>(json);
        }
    }

    private async Task LoadPomodoroCount()
    {
        var today = DateTime.Today.ToString("yyyy-MM-dd");
        var storedDate = await localStorage.GetItemAsync<string>("pomodoroCountDate");
        
        if (storedDate == today)
        {
            _pomodoroCompleted = await localStorage.GetItemAsync<int>("pomodoroCount");
        }
        else
        {
            _pomodoroCompleted = 0;
            await localStorage.SetItemAsync("pomodoroCountDate", today);
            await localStorage.SetItemAsync("pomodoroCount", 0);
        }
    }

    private async Task IncrementPomodoroCount()
    {
        _pomodoroCompleted++;
        await localStorage.SetItemAsync("pomodoroCount", _pomodoroCompleted);
    }

    private void SetToPomodoro()
    {
        if (_timerHasStarted) return;
        
        _timerType = TimerType.Pomodoro;
        ResetTimerToCurrentType();
    }

    private void SetToShortBreak()
    {
        if (_timerHasStarted) return;
        
        _timerType = TimerType.ShortBreak;
        ResetTimerToCurrentType();
    }

    private void SetToLongBreak()
    {
        if (_timerHasStarted) return;
        
        _timerType = TimerType.LongBreak;
        ResetTimerToCurrentType();
    }

    private void ResetTimerToCurrentType()
    {
        if (_pomodoroSettings == null) return;

        _timeLeft = _timerType switch
        {
            TimerType.Pomodoro => TimeSpan.FromMinutes(_pomodoroSettings.PomodoroDuration),
            TimerType.ShortBreak => TimeSpan.FromMinutes(_pomodoroSettings.ShortBreak),
            TimerType.LongBreak => TimeSpan.FromMinutes(_pomodoroSettings.LongBreak),
            _ => TimeSpan.Zero
        };
        
        StateHasChanged();
    }

    private async Task SetTimer()
    {
        _timerHasStarted = !_timerHasStarted;

        if (_timerHasStarted)
        {
            _cancellationTokenSource = new CancellationTokenSource();
            _ = RunTimer(_cancellationTokenSource.Token);
        }
        else
        {
            _cancellationTokenSource?.Cancel();
        }
    }

    private async Task RunTimer(CancellationToken cancellationToken)
    {
        _periodicTimer = new PeriodicTimer(TimeSpan.FromSeconds(1));

        try
        {
            while (await _periodicTimer.WaitForNextTickAsync(cancellationToken))
            {
                if (_timeLeft.TotalSeconds > 0)
                {
                    _timeLeft = _timeLeft.Subtract(TimeSpan.FromSeconds(1));
                    await InvokeAsync(StateHasChanged);
                }
                else
                {
                    // Timer completed
                    _timerHasStarted = false;
                    
                    if (_timerType == TimerType.Pomodoro)
                    {
                        await IncrementPomodoroCount();
                        await PlayNotificationSound();
                    }
                    
                    await InvokeAsync(StateHasChanged);
                    break;
                }
            }
        }
        catch (OperationCanceledException)
        {
            // Timer was cancelled
        }
        finally
        {
            _periodicTimer?.Dispose();
        }
    }

    private async Task PlayNotificationSound()
    {
        if (!_isRendered) return;
        
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", "new Audio('https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3').play()");
        }
        catch
        {
            // Ignore errors if sound playback fails
        }
    }

    private void ResetTimer()
    {
        _timerHasStarted = false;
        _cancellationTokenSource?.Cancel();
        ResetTimerToCurrentType();
    }

    private string GetTimerClass()
    {
        return _timerType switch
        {
            TimerType.ShortBreak => "break",
            TimerType.LongBreak => "long-break",
            _ => ""
        };
    }

    public void Dispose()
    {
        _cancellationTokenSource?.Cancel();
        _cancellationTokenSource?.Dispose();
        _periodicTimer?.Dispose();
    }
}
